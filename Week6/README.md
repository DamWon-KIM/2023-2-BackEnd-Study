##### [출처 : GDSC 백엔드 스터디]
### DB
* DB란? </br>
  ```
  여러 사용자가 공유하여 사용할 수 있도록 통합해서 저장한 운영 데이터의 집합
  간단히 생각하면, 컴퓨터 디스크라고 생각하면 된다.
  다양한 자료를 저장할 수 있다.

  이 때, 이 자료들은 다양한 방식으로 저장될 수 있다.
  대표적인 것으로 : SQL과 NoSQL
  ```

* 통합, 저장, 공유, 운영 데이터
  * 통합 데이터 : 중복을 최소화하고 통제가 가능한 중복만 허용
  * 저장 데이터 : 컴퓨터가 접근할 수 있는 매체에 데이터베이스를 저장해야 함
  * 공유 데이터 : 동시 공유가 가능하고 실시간 접근이 가능하다, 데이터베이스는 계속 변화한다
  * 운영 데이터 : 조직의 주요 기능을 수행하기 위해, 일시적으로 사용하고 마는 것이 아닌, 지속적으로 유지해야 하는 데이터
 
### SQL
* 우리가 흔히 RDB(Relational DataBase)라고 부르는 것 </br>
  엑셀처럼 데이터가 저장된다고 생각하면 된다.

  이는 아래와 같은 특징을 가진다.
  1. 데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
      * -> 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.
      * 스키마 : DB의 구조에 관한 meta data [메타데이터], 명세라고 생각하면 된다.
  2. 데이터는 관계를 통해 여러 테이블에 분산된다.
  3. 중복 데이터는 저장하지 않는다. [통합 데이터의 관점에서]
      * -> 무결성을 보장해준다.

  위와 같은 특징을 가지므로 수정이 빈번하고, 구조와 중요도가 높을 경우 사용하면 좋다.
  이에 해당하는 DB로 MySQL, MsSQL, 오라클 등이 있다.
  이 스터디에서는 SQL을 사용할 예정이다.

 ### NoSQL
* 말 그대로 no SQL이다.
* SQL이 아닌, 즉 스키마도 없고 관계도 없는 자료 형식이다.

  NoSQL 특징
   1. 스키마도 없고 관계도 없는 자료 형식이다.
   2. 관련 데이터를 동일한 '컬렉션'에 넣는다.

  이러한 특징을 가지는 NoSQL은 유연한 구조, 빠른 속도, 확장이 편리하다는 장점을 가진다.
  대표적인 예로 MongoDB, Redis 등이 있다.

  ## ORM
  ### Entity
   * 우리는 데이터베이스에 넣을 객체를 엔티티라고 부르고 아래와 같이 구현한다.
```     
@Entity
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(fetch = FetchType.LAZY)
    private List<Feed> feeds;

    private String name;
}

위는 객체이다. 하지만 데이터베이스에 이 형태로 저장할 수 없다.
이 문제를 해결하기 위해 ORM이 존재한다.
```

### ORM이란?
  * ORM의 정의 </br>
    Object-Relational Mapping </br>
    데이터베이스와 객체 지향 프로그래밍 언어 사이의 관계형 데이터를 객체로 매핑하는 기술이나 프로그래밍 기술 </br>
    위 객체를 데이터베이스의 데이터 형식으로 바꿔 저장해주는 역할을 해준다. </br>
    ORM을 사용하면, SQL을 작성하지 않아도 데이터를 조작할 수 있다는 장점이 있다. </br>
    종류로는 Hibernate, EclipseLink, DataNucleus등이 있다. </br>
    Java를 사용한다면 Hibernate를 주로 접할 수 있다.

  * ORM의 장, 단점
    * 장점
      1. 추상화 : 데이터베이스와의 상호 작용을 객체 지향적인 방식으로 처리할 수 있다.
      2. 데이터베이스 독립성 : 다양한 데이터베이스 시스템에 대해 동일한 코드를 사용할 수 있게 도와준다.
      3. 생산성 : SQL 쿼리를 직접 작성하지 않아도 된다.
      4. 유지 보수 : 코드 변경이 필요할 때, 객체 모델만 수정하면 된다.
         
    * 단점
      1. 성능 : 개발자가 작성한 쿼리보다 비효율적일 수 있다.
      2. 복잡성 : 복잡한 쿼리나 특정 데이터베이스 최적화 기술을 사용하려면 ORM을 벗어나야 할 수 있다.
      위와 같은 장점과 단점이 존재하지만, 개발의 편의를 위해 ORM을 거의 필수적으로 사용하는 편이다.

## JPA
### JPA란?
Java Persistence API </br>
주로 스프링에서 많이 사용하지만, 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방법을 정의한 자바 API이다. </br>
자바 ORM 기술에 대한 표준 사양으로, 객체와 데이터베이스 테이블 간의 매핑을 처리한다. </br>
  * JDBC : 데이터베이스 연결 및 SQL 쿼리 수행을 위한 낮은 수준의 API를 제공함.
    개발자는 SQL 쿼리를 직접 작성하고 실행해야 함.
  * Hibernate : JPA에 대한 구현체(JPA는 인터페이스이다)

이는 아래와 같은 특징을 가진다.
  1. 객체-테이블 매핑 : 어노테이션 또는 XML을 사용하여 자바 객체와 데이터베이스 테이블을 매핑함 </br>
  2. 쿼리 언어 사용 : JPQL (Java Persistence Query Language)라는 객체지향 쿼리 언어를 제공하여 데이터베이스에 질의할 수 있음 </br>
  3. 생명주기 관리 : 엔티티의 생명 주기(예: 생성, 조회, 수정, 삭제)를 관리함 </br>
  4. 캐싱 : 기본적인 캐시 전략을 지원함 </br>
  5. 자동 스키마 생성 : 데이터베이스 스키마를 자동으로 생성하거나 업데이트 할 수 있음 </br>

  JPA는 위와 같은 특성을 영속성 컨텍스트를 이용하여 구현한다. </br>
  영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미한다. </br>

#### 영속성 컨텍스트
```
어플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 저장소 같은 역할
Entity Manage를 통해 영속성 컨텍스트에 접근
```

### Mapping
#### Entity
 데이터베이스의 테이블과 자바 클래스를 매핑하는 역할을 한다.
 엔티티 클래스는 데이터베이스 테이블의 레코드를 객체로 표현하며, JPA를 사용하여 이 객체를 관리할 수 있다.
     
```
@Entity
// 해당 클래스는 JPA가 관리하는 엔터티로 표시되며, 데이터베이스 테이블과 연동될 수 있게 됨
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 이 값이 기본키 임을 나타냄
    private Long id;

    @OneToMany(fetch = FetchType.LAZY)
    private List<Feed> feeds;

    private String name;
}
```
    
  실제 서비스는 무수히 많은 엔티티가 있고, 이 엔티티 간의 관계를 기반으로 다양한 정보를 저장한다. 이를 위해 ERD(Entity-Relation Diagram)을 사용하며, 이 내용을 기반으로 객체를 구현한다. </br>
ERD에는 데이터베이스의 구조에 관한 메타 데이터, 명세를 적어둔다. </br>
  디비에서 데이터의 자료형은 Java의 자료형과 다른 자료형을 사용한다. </br>
  JPA가 알맞은 자료형으로 바꿔주지만, 이를 알고 있어야 ERD를 만들 수 있다. </br>
